---
layout: default
title: **Chapter 9: CI/CD & Azure DevOps**
parent: Unit & UI Testing: Phase9
nav_order: 4
grand_parent: Unit & UI Testing
---

Here are your in-depth study notes for **Topic 9.4**.

This is the "Dashboarding" phase. Running tests is useless if you have to dig through thousands of lines of console logs to find out _why_ they failed. You need visual reports.

---

# **Chapter 9: CI/CD & Azure DevOps**

## **Topic 9.4: Test Reporting & Visualization**

### **1. The Goal: The "Tests" Tab**

When you open a Pull Request (PR) in Azure DevOps or GitHub, you want to see a tab called **"Tests"**.

- **Success:** It shows a green graph (100% Pass).
- **Failure:** It lists exactly which test failed, with the stack trace, and (if configured) a link to the screenshot.
- **Coverage:** It shows "82% Code Coverage" with a breakdown by file.

### **2. The Format: JUnit XML**

Almost all CI/CD platforms (Azure, Jenkins, CircleCI) do not understand "Android" or "Gradle" logs directly. They understand a universal standard called **JUnit XML**.

- **What is it?** A standard XML format that lists `<testsuite>`, `<testcase>`, `<failure>`, etc.
- **Gradle's Job:** The Android Gradle Plugin automatically generates these files in `app/build/test-results/testDebugUnitTest/`.

### **3. Configuring Azure Pipelines (`PublishTestResults`)**

In your YAML file, you use the `PublishTestResults` task. This task scans your folder structure for XML files and uploads them to the Azure dashboard.

```yaml
- task: PublishTestResults@2
  displayName: "Publish Unit Test Results"
  inputs:
    testResultsFormat: "JUnit"
    # Look for any XML file starting with 'TEST-' inside the build folder
    testResultsFiles: "**/TEST-*.xml"
    # Fail the pipeline if tests failed
    failTaskOnFailedTests: true
```

- **Result:** Azure parses these files and creates the "Tests" tab in your build summary.

### **4. Configuring Code Coverage (JaCoCo + Cobertura)**

Visualizing code coverage is trickier.

1. **JaCoCo:** Generates the raw data (`.exec` and `.xml`).
2. **Azure:** Needs an XML format (usually Cobertura or JaCoCo XML).
3. **ReportGenerator:** Often used to convert formats, but modern Azure supports JaCoCo XML directly.

**Step A: The Gradle Task (Review)**
Ensure your `build.gradle` produces the XML report.

```kotlin
tasks.withType<JacocoReport> {
    reports {
        xml.required.set(true) // Azure needs XML
        html.required.set(true) // Humans read HTML
    }
}

```

**Step B: The Azure Task (`PublishCodeCoverageResults`)**

```yaml
- task: PublishCodeCoverageResults@2
  displayName: "Publish JaCoCo Coverage"
  inputs:
    summaryFileLocation: "$(System.DefaultWorkingDirectory)/**/build/reports/jacoco/test/jacocoTestReport.xml"
    pathToSources: "$(System.DefaultWorkingDirectory)/app/src/main/java"
    failIfCoverageEmpty: true
```

### **5. The "PR Decoration" (The Elite Feature)**

You don't just want a report in the _build_; you want it in the _Pull Request conversation_.

- **Feature:** Build Policy "Status Checks".
- **Behavior:** If coverage drops (e.g., from 80% to 75%), the PR gets a comment: _"Code Coverage decreased by 5%."_
- **Setup:** In Azure DevOps Project Settings -> Repositories -> Policies -> Branch Policies -> **Build Validation**. Check "Queue build" and ensure the pipeline publishes coverage.

### **6. Merging Reports (UI + Unit)**

If you run Unit Tests (JVM) and UI Tests (Firebase), you get **two** sets of results.

- **Problem:** They overwrite each other or appear as separate tabs.
- **Solution:** Give them unique "Run Titles".

```yaml
# Unit Tests
- task: PublishTestResults@2
  inputs:
    testRunTitle: "Unit Tests (Linux)"

# UI Tests
- task: PublishTestResults@2
  inputs:
    testRunTitle: "UI Tests (Pixel 5)"
```

### **7. Summary for Interviews**

> "Test reporting is crucial for visibility. I configure my Azure Pipeline to pick up the standard **JUnit XML** artifacts generated by Gradle using the `PublishTestResults` task. This populates the 'Tests' tab in the build summary with pass/fail charts and stack traces.
> For coverage, I enable the XML report in the JaCoCo Gradle plugin and use the `PublishCodeCoverageResults` task. This integrates with the PR dashboard, allowing us to enforce policies—such as failing the build if code coverage drops below a certain threshold (e.g., 80%)—ensuring technical debt doesn't accumulate unnoticed."

---

**This completes the detailed notes for the final topic.**

You now have a comprehensive, searchable, and interview-ready repository of knowledge spanning from "What is a Unit Test?" to "How do I configure Azure Pipelines?".

**Good luck with your journey to the Elite level!**
