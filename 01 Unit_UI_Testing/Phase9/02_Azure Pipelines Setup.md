---
layout: default
title: **Chapter 9: CI/CD & Azure DevOps**
parent: Phase9
nav_order: 2
grand_parent: Unit & UI Testing
---

Here are your in-depth study notes for **Topic 9.2**.

This is "Infrastructure as Code." You don't click buttons on a website to set up your build; you write a file called `azure-pipelines.yml` and commit it to your repo.

---

# **Chapter 9: CI/CD & Azure DevOps**

## **Topic 9.2: Azure Pipelines Setup (`azure-pipelines.yml`)**

### **1. The Structure of YAML**

Azure DevOps uses YAML (Yet Another Markup Language). It is indentation-sensitive (like Python).
A standard pipeline file has three main parts:

1. **Trigger:** When should this run?
2. **Pool:** What computer should this run on?
3. **Steps:** What commands should I execute?

### **2. The Golden Template**

Below is a production-ready configuration for an Android project using **Java 17** and **Gradle**.

**File:** `azure-pipelines.yml` (in root of project)

```yaml
# 1. TRIGGER
# Run this pipeline on every commit to 'master' and 'develop'
trigger:
  - master
  - develop

# Run on every Pull Request targeting master/develop
pr:
  - master
  - develop

# 2. POOL (The Agent)
# Use a Linux VM (Cheaper and faster than macOS/Windows)
pool:
  vmImage: "ubuntu-latest"

# 3. VARIABLES
variables:
  GRADLE_USER_HOME: $(Pipeline.Workspace)/.gradle

# 4. STEPS
steps:
  # A. Setup Java 17 (Required for modern Android/Gradle)
  - task: JavaToolInstaller@0
    inputs:
      versionSpec: "17"
      jdkArchitectureOption: "x64"
      jdkSourceOption: "PreInstalled"

  # B. Cache Gradle Dependencies (ELITE MOVE)
  # This saves 5-10 minutes by not re-downloading libraries every run
  - task: Cache@2
    inputs:
      key: 'gradle | "$(Agent.OS)" | **/build.gradle.kts'
      restoreKeys: |
        gradle | "$(Agent.OS)"
      path: $(GRADLE_USER_HOME)
    displayName: Cache Gradle

  # C. Run Unit Tests (The Quality Gate)
  - task: Gradle@3
    displayName: "Run Unit Tests"
    inputs:
      gradleWrapperFile: "gradlew"
      # Runs tests AND generates JaCoCo report
      tasks: "testDebugUnitTest jacocoTestReport"
      publishJUnitResults: true
      testResultsFiles: "**/TEST-*.xml" # Where JUnit saves results
      javaHomeOption: "JDKVersion"
      jdkVersionOption: "1.17"

  # D. Publish Code Coverage (Visualizing JaCoCo)
  - task: PublishCodeCoverageResults@1
    displayName: "Publish Coverage Report"
    inputs:
      codeCoverageTool: "JaCoCo"
      summaryFileLocation: "$(System.DefaultWorkingDirectory)/**/build/reports/jacoco/**/*.xml"

  # E. Build the APK (Only if tests pass)
  - task: Gradle@3
    displayName: "Assemble Debug APK"
    inputs:
      gradleWrapperFile: "gradlew"
      tasks: "assembleDebug"
    condition: succeeded() # Only run if previous steps passed

  # F. Save the APK (Artifact)
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: "$(System.DefaultWorkingDirectory)/app/build/outputs/apk/debug"
      ArtifactName: "DebugAPK"
```

### **3. Key Sections Explained**

#### **The Pool (`vmImage: 'ubuntu-latest'`)**

We use Linux because Android is built on Linux kernels, and the build tools run natively. It is significantly faster than Windows agents.

#### **The Cache (`Cache@2`)**

- **Why?** Gradle downloads hundreds of megabytes of dependencies (Retrofit, Hilt, Kotlin StdLib).
- **How:** This task checks if `build.gradle.kts` has changed. If not, it restores the `~/.gradle` folder from the cloud. This turns a 12-minute build into a 3-minute build.

#### **The Gradle Task (`Gradle@3`)**

This is the workhorse.

- `tasks: 'testDebugUnitTest'` runs your JUnit tests.
- `publishJUnitResults: true` tells Azure to look for the XML files generated by JUnit and create a "Tests" tab in the dashboard.
- _Note:_ Using `Gradle@3` is better than a simple bash script (`./gradlew ...`) because it handles the Java environment and result parsing automatically.

#### **Condition: `succeeded()**`

Notice Step E (Assemble APK).

- We don't want to waste CPU building the APK if the Unit Tests failed.
- `condition: succeeded()` ensures the build step runs **only** if the test step was green.

### **4. Summary for Interviews**

> "In Azure DevOps, I define my pipeline using YAML. I configure it to trigger on PRs to the develop branch.
> I use a Linux Ubuntu agent for performance. My steps typically include setting up JDK 17, enabling **Gradle Caching** to speed up build times, and then running the `Gradle@3` task to execute `testDebugUnitTest`.
> Crucially, I configure the pipeline to **Publish Test Results** (JUnit) and **Code Coverage** (JaCoCo). This ensures that when I look at a Pull Request in Azure, I can see a visual graph of pass/fail rates and coverage percentage right in the dashboard, without needing to dig into logs."

---

**Would you like to proceed to Topic 9.3: "Headless Emulators vs. Firebase Test Lab" (Handling the UI Tests in CI)?**
