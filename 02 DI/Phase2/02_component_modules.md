---
layout: default
title: "Implementing @Component and @Inject"
parent: "Phase 2: Dagger 2 - The Engine"
nav_order: 2
grand_parent: "Dependency Injection"
---

Here are the detailed notes for the second topic of Phase 2, strictly adhering to the "Book Style" format and the interview summary structure.

---

# Phase 2: Dagger 2 â€“ Topic 2: Implementing @Component and @Inject

We have introduced Dagger as a code generator. Now, we must provide it with the instructions it needs to generate that code. In Manual DI, we wrote the creation logic ourselves inside the `AppContainer`. In Dagger, we simply "tag" our classes and interfaces, and Dagger writes the container for us.

### 1. The `@Inject` Annotation (The Recipe)

The first step in any Dagger setup is to tell Dagger **how** to create an object. We do this by placing the `@Inject` annotation on the constructor of the class.

When Dagger sees `@Inject constructor(...)`, it adds this class to its internal "knowledge base." It analyzes the parameters in the constructor and marks them as dependencies that it must also find.

**Code Demonstration:**

```kotlin
// 1. The Leaf Node
// We define an empty constructor so Dagger knows it can create this freely.
class RemoteDataSource @Inject constructor() {
    fun getData() = "Data from API"
}

// 2. The Dependent Node
// Dagger sees '@Inject', checks the constructor arguments,
// and realizes it needs a 'RemoteDataSource'.
// It looks up 'RemoteDataSource' in its graph (Step 1) and injects it.
class UserRepository @Inject constructor(
    private val remoteDataSource: RemoteDataSource
) {
    fun getUser() = remoteDataSource.getData()
}

```

_Note: We did not write any `new` or `val =` code. We just declared the relationship._

### 2. The `@Component` (The Bridge)

Annotating classes isn't enough. We need an entry pointâ€”a way to reach into the graph and pull objects out. This is the role of the **Component**.

The Component is an interface that we define. It acts as the bridge between the **Consumer** (our Activity) and the **Provider** (the Dagger Graph). It replaces our manual `AppContainer`.

**Code Demonstration:**

```kotlin
// We use an Interface, not a Class. Dagger implements it for us.
@Component
interface AppComponent {

    // METHOD 1: Provision Method (Getter)
    // "Dagger, please give me a UserRepository."
    // Dagger checks if it knows how to build UserRepository (it does, via @Inject).
    fun getUserRepository(): UserRepository

    // METHOD 2: Injection Method (Member Injection)
    // "Dagger, take this Activity and fill in its @Inject variables."
    // This is used for Android Framework classes (Activities/Fragments).
    fun inject(activity: LoginActivity)
}

```

### 3. The Build Process (The Magic Moment)

In Manual DI, you write the code and run the app. In Dagger, there is an intermediate step.
After you write the `@Component` interface, you **must build the project** (Build -> Make Project).

During this build, Dagger's Annotation Processor runs. It reads `AppComponent`, sees you want a `UserRepository`, looks at `UserRepository`, sees the `@Inject` constructor, and generates a real Java/Kotlin file named `DaggerAppComponent`.

**This `DaggerAppComponent` is the actual container code.** It looks almost identical to the `AppContainer` we wrote by hand in Phase 1!

### 4. Wiring it to the Activity

Now we use the generated code to perform the injection.

```kotlin
class LoginActivity : AppCompatActivity() {

    // FIELD INJECTION
    // We mark this property with @Inject so Dagger knows what to fill.
    // It must be public/internal (not private) and 'lateinit var'.
    @Inject
    lateinit var userRepository: UserRepository

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // 1. Instantiate the Dagger Component
        // 'DaggerAppComponent' is the class generated by the compiler.
        val appComponent = DaggerAppComponent.create()

        // 2. Inject this activity
        // This is the moment Dagger populates the 'userRepository' variable.
        appComponent.inject(this)

        // 3. Use dependencies
        println(userRepository.getUser())
    }
}

```

### 5. Why this is "Elite"

A junior developer might look at `DaggerAppComponent.create()` and think it's magic. An elite developer knows that `DaggerAppComponent` is just a factory class that contains the exact same instantiation logic (`new UserRepository(new RemoteDataSource())`) that we learned to write manually. There is no mystery; it is just automated typing.

---

## ðŸ›‘ Interview Summary: @Component & @Inject

### **Keywords**

Entry Point, Provision Method, Member Injection, Generated Code, Annotation Processor, Constructor Injection, Graph Traversal, Wiring, Interface Implementation, `Dagger<ComponentName>`

### **Paragraph for Interview**

"The core of Dagger involves two main parts: the `@Inject` annotation and the `@Component` interface. I use `@Inject` on the constructor of my classes to tell Dagger _how_ to instantiate them and what dependencies they require. This adds them to the dependency graph. Then, I define a `@Component` interface which acts as the bridge between this graph and my Android classes. When I build the project, Dagger generates an implementation of this interfaceâ€”prefixed with `Dagger`â€”which contains the actual code to create and supply these dependencies. This generated component exposes methods to either return an object directly or inject dependencies into a target class like an Activity."

---

### **Next Step**

We have handled classes we own (`UserRepository`). But what about classes we **don't** own?
Example: **Retrofit**, **Gson**, or **SharedPreferences**. We cannot open the `Retrofit` library code and add `@Inject` to its constructor.

This requires a new concept: **Modules and @Provides**.

Shall we proceed to **Topic 3: Modules & @Provides (Injecting Third-Party Libraries)**?
