---
layout: default
title: Test Semantics
parent: 11. Testing in Compose
nav_order: 1
---

# Test Semantics

Here are your notes for **Topic 10.3**.

---

## **Topic 10.3: UI Testing (Semantics)**

### **1. What It Is**

When you write a UI test in Compose, you don't look at the actual pixels or the Kotlin classes (like `Button` or `Row`).
Instead, you interact with the **Semantics Tree**.
This is a parallel tree generated by Compose that describes the _meaning_ of your UI (e.g., "This is a clickable button labeled 'Login'"). It is the exact same tree used by Accessibility services (TalkBack).

### **2. Why It Exists (The "User" Perspective)**

- **Decoupling:** Tests shouldn't break just because you wrapped a Text widget in a Box. The Semantics tree stays flat and stable even if the visual hierarchy changes.
- **Accessibility First:** If your UI is hard to test (can't find the "Login" button), it's probably hard for a blind user to navigate too. Testing forces you to build accessible apps.

### **3. How It Works**

#### **A. Finding Nodes (`Rule.onNode...`)**

You use the `composeTestRule` to find nodes in the tree.

- **`onNodeWithText("Submit")`:** (Best) Finds by visible text. Simulates how a real user scans the screen.
- **`onNodeWithContentDescription("Settings")`:** Finds by icon description.
- **`onNodeWithTag("submit_btn")`:** (Fallback) Finds by a developer-defined ID.

#### **B. The `testTag` Modifier**

Sometimes an element has no text (like a colored box) or the text changes dynamically. In these cases, you attach a specific tag using `Modifier.testTag("tag_id")`.

- _Note:_ Use this sparingly. Testing by text is better because it verifies what the user actually sees.

### **4. Example: Testing a Counter**

**The UI Code:**

```kotlin
@Composable
fun CounterScreen() {
    var count by remember { mutableIntStateOf(0) }

    Column {
        // We use a tag because the text changes ("Count: 0", "Count: 1")
        Text(
            text = "Count: $count",
            modifier = Modifier.testTag("counter_text")
        )

        Button(onClick = { count++ }) {
            Text("Add")
        }
    }
}

```

**The Test Code:**

```kotlin
@get:Rule
val composeTestRule = createComposeRule()

@Test
fun testCounterIncrements() {
    // 1. Setup
    composeTestRule.setContent { CounterScreen() }

    // 2. Verify Initial State
    composeTestRule
        .onNodeWithTag("counter_text")
        .assertTextEquals("Count: 0")

    // 3. Perform Action (Click "Add")
    // We prefer finding by Text for buttons
    composeTestRule
        .onNodeWithText("Add")
        .performClick()

    // 4. Verify New State
    composeTestRule
        .onNodeWithTag("counter_text")
        .assertTextEquals("Count: 1")
}

```

### **5. Interview Prep**

**Interview Keywords**
Semantics Tree, `testTag`, `onNodeWithText`, `performClick`, `assertIsDisplayed`, Merged Semantics (how a Button merges its Text child), `composeTestRule`.

**Interview Speak Paragraph**

> "In Compose, UI tests interact with the Semantics Tree rather than the view hierarchy. This is beneficial because it aligns testing with accessibility—if a node is findable by a test, it's generally findable by TalkBack. I prioritize finding nodes using `onNodeWithText` or `onNodeWithContentDescription` because this mimics how a real user finds elements. For dynamic content or graphical elements without text, I use `Modifier.testTag` as a stable identifier. I usually assert states using `assertIsDisplayed` or `assertTextEquals` to ensure the UI is reacting correctly to user interactions."

---

**Next Step:**
You can test logic, but how do you verify the UI doesn't look "ugly" or broken on different screen sizes?
Ready for **Topic 10.4: Screenshot Testing (Paparazzi/Roborazzi)**? This is the final piece of the quality puzzle.

---

## Navigation

Next â†’
