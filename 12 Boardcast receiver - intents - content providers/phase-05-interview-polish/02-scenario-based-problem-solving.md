---
layout: default
title: "Scenario Based Problem Solving"
parent: "Phase 5: Interview Final Polish"
nav_order: 2
---

# Scenario Based Problem Solving

This is a classic "Senior Engineer" question because it tests your ability to choose the right tool for the job based on **security, lifecycle, and data size.** In a high-traffic environment, you can't just pick the easiest way; you have to pick the most robust one.

---

## **Scenario: Inter-App Communication**

### **The Problem**

App A (the Downloader) finishes a large file download. App B (the Viewer/Processor) needs to be notified immediately so it can process that file.

**Constraints:**

1. **Security:** App B should only access that specific file, not App A's whole storage.
2. **Reliability:** The notification must work even if App B is not currently running.
3. **Data Size:** The file is large (e.g., a 50MB PDF or Video), so we cannot "pass" the file itself.

---

### **The Solution: The "Broadcast + FileProvider" Pattern**

To solve this, we use a combination of **Broadcast Receivers** (for the signal) and **Content Providers/FileProvider** (for the data access).

#### **Step 1: Secure the Data (App A)**

App A should store the file in its internal private storage. To share it, App A defines a **FileProvider**. This ensures App B doesn't need "Storage Permissions" to see the file; it only needs a temporary URI.

#### **Step 2: Send the Signal (App A)**

Once the download is 100% complete, App A sends a **Broadcast Intent**.

- It should be an **Explicit Intent** (if we know App B's package) or a **Custom Action** with **Signature Permissions** to ensure only our trusted App B can hear it.
- The Intent will carry the `content://` URI of the file generated by the FileProvider.

#### **Step 3: Receive and Process (App B)**

App B has a **Broadcast Receiver** registered (either statically in the Manifest if it's a critical event, or via WorkManager).

- It receives the URI.
- It calls `getContentResolver().openInputStream(uri)` to read the file.

---

### **How It Works (Logic Flow)**

1. **App A** finishes download -> Saves to `internal_folder/download.zip`.
2. **App A** calls `FileProvider.getUriForFile()` -> Result: `content://com.appa.provider/shares/download.zip`.
3. **App A** creates Intent with Action `com.myapp.ACTION_DOWNLOAD_COMPLETE`.
4. **App A** attaches the URI and adds `Intent.FLAG_GRANT_READ_URI_PERMISSION`.
5. **App A** sends the broadcast.
6. **App B**'s Receiver triggers -> Extracts URI -> Opens file stream to process.

---

### **Code Example (SDE-II Level)**

**App A: Sending the notification**

```kotlin
val downloadedFile = File(filesDir, "downloads/report.pdf")
val contentUri = FileProvider.getUriForFile(context, "com.appa.provider", downloadedFile)

val intent = Intent("com.appb.ACTION_PROCESS_FILE").apply {
    setPackage("com.appb.package") // Targeting App B specifically for security
    putExtra("EXTRA_FILE_URI", contentUri)
    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) // Granting temp access
}
sendBroadcast(intent)

```

**App B: Receiving the notification**

```kotlin
class FileReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val fileUri: Uri? = intent.getParcelableExtra("EXTRA_FILE_URI")

        fileUri?.let {
            // Use WorkManager to process the file in the background
            val workRequest = OneTimeWorkRequestBuilder<FileProcessingWorker>()
                .setInputData(workDataOf("URI_PATH" to it.toString()))
                .build()
            WorkManager.getInstance(context).enqueue(workRequest)
        }
    }
}

```

---

### **Interview Keywords**

- **Decoupling**: App A and App B don't need to know each other's internal logic.
- **Temporary URI Permission**: Using flags instead of broad storage permissions.
- **Signature-Level Security**: Ensuring only your apps can talk to each other.
- **Offloading**: Using WorkManager to handle the file processing so the Receiver doesn't block the main thread.

---

### **Interview Speak Paragraph**

> "To design a system where App A notifies App B of a completed download, I would implement a secure hand-off using **FileProvider** and a **Custom Broadcast**. App A would generate a temporary `content://` URI for the file and send an explicit broadcast to App B, including the `FLAG_GRANT_READ_URI_PERMISSION`. This avoids the need for broad storage permissions and prevents sensitive data leaks. On the receiving end, App B would catch the intent and immediately hand off the URI to **WorkManager** for background processing. This ensures the communication is secure, battery-efficient, and follows Android’s modern background execution limits."

---

### **Common Interview "Follow-up" Questions**

- **"What if App B is killed when the broadcast is sent?"**
- _Answer:_ If the receiver is declared in the **Manifest (Static)**, the system will wake up App B's process to deliver the broadcast. However, if the event isn't "instant," it's better to have App B check a **Content Provider** (Syncing) when it next starts up.

- **"Why not use a Service instead of a Broadcast?"**
- _Answer:_ Starting a Service from another app is more restricted in newer Android versions. A Broadcast is a lighter "ping" that can then trigger a Job or Worker, which is more compliant with Android's battery-saving policies.

---

**Would you like to try another scenario, perhaps involving "Deep Linking" or "Real-time Data Syncing" between apps?**

---

[â¬… Back to Phase Overview](../)
